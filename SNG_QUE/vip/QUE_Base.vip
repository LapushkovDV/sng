/*************************************************************************************************\
* Наименование: Базовый объект работы очереди                                                     *
* Контур/Модуль: Очередь исходящих сообщений                                                      *
* Примечание:                                                                                     *
*                                                                                                 *
* Вид работы  |Номер         |Дата    |Исполнитель              |Проект                           *
* ----------------------------------------------------------------------------------------------- *

\*************************************************************************************************/
/*
  Status|  QUE_EntriesForReview                                   |  QUE_OUT
------------------------------------------------------------------------------------
       0|   ожидает обработки для формирования JSON               |
       1|   готова к передаче в очередь (JSON сформирован)        | готова к передаче во внешнюю систему
       2|   ожидает обработки связанных записей (JSON сформирован)| ожидает вставки связанных записей в очередь
       3|   ошибка при генерации JSON                             | ошибка передачи во внешнюю систему
       4|   успешно передана в очередь                            | успешно передана
       5|   ошибка передачи в очередь                             | не все записи из пула переданы во внешнюю систему
*/
#include QUE_BASE.vih
#include QRY_OUT.vih

table struct tmpEntriesForReview (
   cEntriesForReview : comp
 , DateTime_in       : datetime
)
with index (
 ind0 = cEntriesForReview
)
;
Interface QUE_BASE 'QUE базовый объект';
function isExistStatusInPool(_cEntriesForReview: comp; _status : word) : boolean; forward;
create view
var
   _logQUE_OUT : string; //глобальная
 as select
 QUE_OUT.nrec
from
   QUE_OUT
 , QUE_EntriesForReview QUE_EntrRvwIns
 , QUE_EntriesForReview QUE_EntrRvwGenJSON
 , QUE_EntriesForReview QUE_EntrRvwIns_1
// , QUE_EntriesForReview QUE_EntrRvwLoop
 , QUE_EntriesForReview QUE_EntrRvwLoop_status
 , QRY_Instance QRY_Instance_1
 , QRY_Template QRY_INST_TMPLT_1

 , tmpEntriesForReview
;

Function GetNameStatusEntriesForReview(_Status : word) : string; cacheable;{
 case _Status of
   coPreQUE_AwaitProcessJSONgenerate    : result := 'ожидает обработки для формирования JSON'// 0; //  ожидает обработки для формирования JSON
   coPreQUE_WaitForRelatedRcrdsToInsert : result := 'ожидает вставки связанных записей' // 1 //  ожидает вставки связанных записей
   coPreQUE_ReadyToTransferToQueue      : result := 'готова к передаче в очередь (JSON сформирован)' // 2; //  готова к передаче в очередь (JSON сформирован)
   coPreQUE_AwaitProcessRelatedRcrd     : result := 'ожидает генерации JSON в связанных записях' // 3; //  ожидает генерации JSON в связанных записях (JSON сформирован)
   coPreQUE_ErrorGenerateJSON           : result := 'ошибка при генерации JSON' // 4; //  ошибка при генерации JSON
   coPreQUE_SuccessTransferToQueue      : result := 'успешно передана в очередь' // 5; //  успешно передана в очередь
   coPreQUE_ErrorTransferToQueue        : result := 'ошибка передачи в очередь' // 6; //  ошибка передачи в очередь
  else {
    result := '--неизвестный статус--' //
  }
 end;
}

Function GetImageStatusEntriesForReview(_Status : word) : string; cacheable;{

case _Status of
   coPreQUE_AwaitProcessJSONgenerate    : result := 'SNG_QUE::bmpQUE_STATUS_YellowL';  // ожидает обработки для формирования JSON
   coPreQUE_WaitForRelatedRcrdsToInsert : result := 'SNG_QUE::bmpQUE_STATUS_YellowL';   // ожидает вставки связанных записей
   coPreQUE_ReadyToTransferToQueue      : result := 'SNG_QUE::bmpQUE_STATUS_BlueL'; // готова к передаче в очередь (JSON сформирован)
   coPreQUE_AwaitProcessRelatedRcrd     : result := 'SNG_QUE::bmpQUE_STATUS_YellowL';   // ожидает генерации JSON в связанных записях (JSON сформирован)
   coPreQUE_ErrorGenerateJSON           : result := 'SNG_QUE::bmpQUE_STATUS_RedL';     // ошибка при генерации JSON
   coPreQUE_SuccessTransferToQueue      : result := 'SNG_QUE::bmpQUE_STATUS_LimeL';  // успешно передана в очередь
   coPreQUE_ErrorTransferToQueue        : result := 'SNG_QUE::bmpQUE_STATUS_RedL';     // ошибка передачи в очередь
  else {
    result := ColorSysBlack;
  }
 end;

/* case _Status of
   coPreQUE_AwaitProcessJSONgenerate    : result := ColorSysBlack;  // ожидает обработки для формирования JSON
   coPreQUE_WaitForRelatedRcrdsToInsert : result := ColorSysGray;   // ожидает вставки связанных записей
   coPreQUE_ReadyToTransferToQueue      : result := ColorSysPurple; // готова к передаче в очередь (JSON сформирован)
   coPreQUE_AwaitProcessRelatedRcrd     : result := ColorSysGray;   // ожидает генерации JSON в связанных записях (JSON сформирован)
   coPreQUE_ErrorGenerateJSON           : result := colorerror;     // ошибка при генерации JSON
   coPreQUE_SuccessTransferToQueue      : result := ColorSysGreen;  // успешно передана в очередь
   coPreQUE_ErrorTransferToQueue        : result := colorerror;     // ошибка передачи в очередь
  else {
    result := ColorSysBlack;
  }
 end;
 */
}


Function GenerateNewFile: string; {
 result := GetStringParameter('Files','OutputFilesDirectory',0)+ '\QUE_'+DateToStr(cur_date,'YYYYMMDD')+'_'+timetostr(cur_time,'HHMMSS-SSS');
}

function GetLogFile : string; {
  if _logQUE_OUT = '' then _logQUE_OUT := GenerateNewFile+'.log';
  result := _logQUE_OUT;
}

Procedure MyLog(_str: string; _needlog : boolean = false); {
  LogStrToFile(GetLogFile,DateToStr(cur_date,'YYYYMMDD')+'_'+timetostr(cur_time,'HHMMSS') + ': ' + shortstrtowin(_str));
}

Function InsertEntriesForReview(_cParent : comp; _Status : word; _TypeEvent : string[20]; _InstanceCode : string; _AddWhereStr : string) : comp; {
  result := 0h;
   ClearBuffer(tnQUE_EntrRvwIns);
   QUE_EntrRvwIns.cParent           := _cParent          ; // "Ссылка вышестоящую запись"
   QUE_EntrRvwIns.Status            := _Status           ; // "Статус обработки"
   QUE_EntrRvwIns.TypeEvent         := _TypeEvent        ; // "Тип события"
   QUE_EntrRvwIns.QRY_Instance_code := _InstanceCode     ; // "Код экземпляра запроса"
   QUE_EntrRvwIns.AddWhereStr       := _AddWhereStr      ; // "Строка-доп.условия в запрос"
   QUE_EntrRvwIns.DateTime_in       := _curdatetime      ; // Дата-время создания записи
  if(Insert current QUE_EntrRvwIns) = tsOK {
    result := QUE_EntrRvwIns.nrec;
  }
}
function getRootTableNameByInstanceCode(_InstanceCode : string) : string; cacheable;{
   result := '----- не найден экземпляр запроса с кодом "' + _InstanceCode+'"  -----';
   if getfirst fastfirstrow QRY_Instance_1 where ((_InstanceCode == QRY_Instance_1.code)) = tsOK then {
   if getfirst fastfirstrow QRY_INST_TMPLT_1 where ((QRY_Instance_1.cTmplt == QRY_INST_TMPLT_1.nrec)) = tsOK {
      var iQRY_OUT : QRY_OUT new;
      result := iQRY_OUT.GetTableNameByCode(QRY_INST_TMPLT_1.TABLECODE)
    }
   }
}
Function InsertEntriesForReview_PoolParent(_cParent : comp;
                                           _TypeEvent : string[20];
                                           _InstanceCode : string;
                                           _AddWhereStr : string = '';
                                           _nrecRootTable : comp= 0h) : comp; {
  if _nrecRootTable <> 0h {
     _AddWhereStr := 'and ' + getRootTableNameByInstanceCode(_InstanceCode) + '.nrec = ' + string(_nrecRootTable);
    }
  result := InsertEntriesForReview(_cParent, coPreQUE_WaitForRelatedRcrdsToInsert, _TypeEvent, _InstanceCode, _AddWhereStr);
}

Procedure SetPoolRecordsStatus(_cMainParent : comp; _CheckStatus, _ToStatus : word); {
   _loop QUE_EntrRvwIns where ((_cMainParent == QUE_EntrRvwIns.cParent)) {
     if QUE_EntrRvwIns.status <> _CheckStatus // coPreQUE_WaitForRelatedRcrdsToInsert
         then continue; //если статус не равен ожидает вставки связанных записей, то пропускаем - видимо уже обработали
     if(getfirst QUE_EntrRvwIns_1 where ((QUE_EntrRvwIns.nrec == QUE_EntrRvwIns_1.cParent)) ) = tsOK {
         pushpos(tnQUE_EntrRvwIns);
          SetPoolRecordsStatus(QUE_EntrRvwIns.nrec, _CheckStatus, _ToStatus);
         poppos(tnQUE_EntrRvwIns);
      }

     update current QUE_EntrRvwIns set QUE_EntrRvwIns.status := _ToStatus ; // coPreQUE_AwaitProcessJSONgenerate;
   }
}

Procedure SetPoolRecordsReadyToGenerateJSON(_cMainParent : comp); {
 if getfirst QUE_EntrRvwIns where ((_cMainParent == QUE_EntrRvwIns.nrec and 0h == QUE_EntrRvwIns.cParent (noindex))) <> tsOK then exit;

  SetPoolRecordsStatus(_cMainParent, coPreQUE_WaitForRelatedRcrdsToInsert, coPreQUE_AwaitProcessJSONgenerate);
   if getfirst QUE_EntrRvwIns where ((_cMainParent == QUE_EntrRvwIns.nrec)) = tsOK {
     update current QUE_EntrRvwIns set QUE_EntrRvwIns.status := coPreQUE_AwaitProcessJSONgenerate ; // coPreQUE_AwaitProcessJSONgenerate;
   }
}

Function InsertEntriesForReview_Single(_TypeEvent : string[20]; _InstanceCode : string; _AddWhereStr : string = ''; _nrecRootTable : comp= 0h) : comp; {
  if _nrecRootTable <> 0h {
     _AddWhereStr := 'and ' + getRootTableNameByInstanceCode(_InstanceCode) + '.nrec = ' + string(_nrecRootTable);
    }

  result := InsertEntriesForReview(0h, coPreQUE_AwaitProcessJSONgenerate, _TypeEvent, _InstanceCode, _AddWhereStr);
}

Procedure GenerateJSONInEntriesForReview(_cQUE_EntriesForReview : comp); {
  if getfirst fastfirstrow QUE_EntrRvwGenJSON where ((_cQUE_EntriesForReview == QUE_EntrRvwGenJSON.nrec)) <> tsOK then exit;

  if QUE_EntrRvwGenJSON.Status <> coPreQUE_AwaitProcessJSONgenerate then exit; // если статус е равен "ожидает обработки для формирования JSON"

  var iQRY_OUT : QRY_OUT new;
  var _err : string = '';
  var FNservice, _JSON : tptr;
  if not iQRY_OUT.GenerateJSONFromQueryInstanceWithAddWhereString(QUE_EntrRvwGenJSON.QRY_Instance_code, QUE_EntrRvwGenJSON.AddWhereStr, FNservice, _JSON, _err){
      var __log : string = iQRY_OUT.GetLogFile;
       ImportFileToMemo(QUE_EntrRvwGenJSON.JSON, __log, false);
       QUE_EntrRvwGenJSON.Status := coPreQUE_ErrorGenerateJSON; // ошибка при генерации JSON
       QUE_EntrRvwGenJSON.DateTime_genJSON := _curdatetime;
       QUE_EntrRvwGenJSON.err    := _err;
      update current QUE_EntrRvwGenJSON;
   }
  else {
      var _jsonFile : string = iQRY_OUT.GenerateNewFile+'.json';
       HttpConnect_SaveToFileEx(FNservice, _JSON, _jsonFile, cpUTF8, false);
       ImportFileToMemo(QUE_EntrRvwGenJSON.JSON, _jsonFile, false);
       QUE_EntrRvwGenJSON.Status := coPreQUE_ReadyToTransferToQueue;
       QUE_EntrRvwGenJSON.DateTime_genJSON := _curdatetime;
      update current QUE_EntrRvwGenJSON;
  }
}

procedure RecursiveGenerateJSON_from_EntriesForReviewRecords(_cEntriesForReview : comp); {
   _loop QUE_EntrRvwIns where ((_cEntriesForReview == QUE_EntrRvwIns.cParent))  {
//      update current QUE_EntrRvwIns set QUE_EntrRvwIns.Status := coPreQUE_AwaitProcessRelatedRcrd; // идем сверху вниз и всем сначала ставим 'ожидает генерации JSON в связанных записях'
     if(getfirst QUE_EntrRvwIns_1 where ((QUE_EntrRvwIns.nrec == QUE_EntrRvwIns_1.cParent)) ) = tsOK {
         pushpos(tnQUE_EntrRvwIns);
          RecursiveGenerateJSON_from_EntriesForReviewRecords(QUE_EntrRvwIns.nrec);
         poppos(tnQUE_EntrRvwIns);
      }

    if isExistStatusInPool(QUE_EntrRvwIns.nrec,coPreQUE_ErrorGenerateJSON) then  {// если есть записи с "ошибка при генерации JSON
         QUE_EntrRvwIns.status := coPreQUE_ErrorGenerateJSON;
         QUE_EntrRvwIns.err    := 'Ошибки в подчиненных записях';
        update current QUE_EntrRvwIns ;
    }
    else {
       GenerateJSONInEntriesForReview(QUE_EntrRvwIns.nrec); // а вот тут генерим JSON  и ставим 'готова к передаче в очередь (JSON сформирован)'
      }
   }
}

function isExistStatusInPool(_cEntriesForReview: comp; _status : word) : boolean; {
  result := false;
  _loop QUE_EntrRvwLoop_status where ((_cEntriesForReview == QUE_EntrRvwLoop_status.cParent)) {
    if QUE_EntrRvwLoop_status.status = _status then {
      result := true;
      exit;
    }
     pushpos(tnQUE_EntrRvwLoop_status);
      result := isExistStatusInPool(QUE_EntrRvwLoop_status.nrec, _status);
     poppos(tnQUE_EntrRvwLoop_status);
     if result = True then exit;
   }
}

procedure GenerateJSON_from_EntriesForReviewRecords(_cEntriesForReview : comp); {
   RecursiveGenerateJSON_from_EntriesForReviewRecords(_cEntriesForReview );

   if getfirst QUE_EntrRvwGenJSON where ((_cEntriesForReview == QUE_EntrRvwGenJSON.nrec)) <> tsOk then exit;
    if isExistStatusInPool(QUE_EntrRvwGenJSON.nrec,coPreQUE_ErrorGenerateJSON) then  {// если есть записи с "ошибка при генерации JSON
       QUE_EntrRvwGenJSON.err    := 'Ошибки в подчиненных записях';
       QUE_EntrRvwGenJSON.status := coPreQUE_ErrorGenerateJSON;
       update current QUE_EntrRvwGenJSON;
    }
    else {
        GenerateJSONInEntriesForReview(_cEntriesForReview); // а вот тут генерим JSON  и ставим 'готова к передаче в очередь (JSON сформирован)'
      }
}

procedure SetStatusGenerateJSON(_cMainParent : comp); {
   if getfirst fastfirstrow QUE_EntrRvwGenJSON where ((_cMainParent == QUE_EntrRvwGenJSON.nrec )) <> tsOK then exit;
   if QUE_EntrRvwGenJSON.status = coPreQUE_ReadyToTransferToQueue then exit; // одиночные записи уже имеют статус для передачи "готова к передаче в очередь (JSON сформирован)"

    if isExistStatusInPool(QUE_EntrRvwGenJSON.nrec,coPreQUE_AwaitProcessJSONgenerate) then exit; // есть воообще необработанные записи в статусе "ожидает обработки для формирования JSON"

    if isExistStatusInPool(QUE_EntrRvwGenJSON.nrec,coPreQUE_WaitForRelatedRcrdsToInsert) then exit; // есть воообще необработанные записи в статусе ожидает вставки связанных записей

    if isExistStatusInPool(QUE_EntrRvwGenJSON.nrec,coPreQUE_ErrorGenerateJSON) then  {// если есть записи с "ошибка при генерации JSON
     update current QUE_EntrRvwGenJSON set QUE_EntrRvwGenJSON.status := coPreQUE_ErrorGenerateJSON;
     exit;
    }

    if not isExistStatusInPool(QUE_EntrRvwGenJSON.nrec,coPreQUE_AwaitProcessRelatedRcrd) then exit; // если есть записи с "ожидает генерации JSON в связанных записях (JSON сформирован)"

    SetPoolRecordsStatus(_cMainParent, coPreQUE_AwaitProcessRelatedRcrd, coPreQUE_ReadyToTransferToQueue);
}

procedure ProcessEntriesForReview; {
 delete all tmpEntriesForReview;
 _try
    {
      sql
      select top 100
         QUE_EntriesForReview.nrec as cEntriesForReview
       , QUE_EntriesForReview.DateTime_in as DateTime_in
      from QUE_EntriesForReview
      where   QUE_EntriesForReview.status = :(coPreQUE_AwaitProcessJSONgenerate)
         and QUE_EntriesForReview.cParent = :(0h)
      order by QUE_EntriesForReview.DateTime_in
       into tmpEntriesForReview;
    }
    _except
    else {
      exit;
    }
 _loop tmpEntriesForReview {
    GenerateJSON_from_EntriesForReviewRecords(tmpEntriesForReview.cEntriesForReview);
//    SetStatusGenerateJSON(tmpEntriesForReview.cEntriesForReview);
  }

}


end.
