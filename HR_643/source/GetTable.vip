//#include absTables.vih
/* ────────────────────────────────────────────────────────────────────────── */
// аналогично как с полями таблиц, никто не разбирался что и зачем..
//почистил, убрал лишнее
Interface GetOneTable 'Выбор таблицы' (, hciGetOneTable,) DoAccept, Cyan;

  Create view
  var cTable : word;
   As
  Select X$Files.XF$CODE
  from X$Files
    where (X$Files.XF$Code > 0)
    ;

  Parameters cTable;

  QuickChoice qcSelectTable
  {
     AcceptField = x$Files.xf$Code; 
     SearchField = x$Files.xf$Name;
     ViewField   = x$Files.xf$Name;
     OnClose:      cTable := x$Files.xf$Code;
  };
  Browse bwTable;
    Table x$Files;
    Fields
      x$Files.xf$Code  'Код'        ('Уникальный номер таблицы в словаре'):  [5], Protect, NoDel, NoPickbutton;
      x$Files.xf$Name  'Имя таблицы'             ('Имя таблицы в словаре'): [20], Protect, NoDel, NoPickbutton;
      x$Files.xf$Title 'Заголовок таблицы' ('Заголовок таблицы в словаре'): [30], Protect, NoDel, NoPickbutton;
  end;

  HandleEvent
    cmInit:
      {
          if GetFirst x$Files <> tsOk
          {
             Message('Нет таблиц для выбора', error);
             abort;
          }
         if cTable <> 0
            if GetFirst x$Files where ((cTable == x$Files.xf$Code)) = tsOk {};
      }
    cmDefault: cTable := x$Files.xf$Code;
  end;
end.


/* ────────────────────────────────────────────────────────────────────────── */
/*
Interface GetTables 'Выбор таблиц' (, hciGetTables,);

  var  sMode   : String;
       Markers : pointer;
  ;
  Parameters Markers, sMode;

  HandleEvent
    cmInit:
      {
        Mode := sMode;
        if Inherited :: HandleEvent(cmInit) = heAbort abort;
        else
        {
           if Markers <> 0
           {
              pMarker.UnselectAll;
              var wCode: word = 0;
              var i: longint = SortedContainer_GetCount(Markers);
              while SortedContainer_At(Markers, --i, wCode) do
                 pMarker.MarkUnMarkRec(wCode);
           }
        }
      }
    cmDefault:
      {
        if pMarker.Count = 0 
           pMarker.MarkUnMarkRec(x$Files.xf$Code);
        SortedContainer_DeleteAll(Markers);
        ResetBounds(tnpMarker);
        _Loop pMarker
           SortedContainer_Insert(Markers, word(pMarker.pNRec));
        SetBounds(tnpMarker);
      }
  end;
end.
*/
