Function  ImportObjectByCode( parJObject : TPtr ) : boolean;
{
   result := false;

   //--
   var parObjCode : word = word(getJsonStrValue('ObjectCode',  parJObject))

   if parObjCode = 0
   {
      LogStrToFile( lsImportLog, 'не указан код объекта parObj='+parObjCode)
      Exit;
   }
   if getFirst JOBJECTS1 where ((  parObjCode == JOBJECTS1.Code )) = TsOk
   {
      LogStrToFile( lsImportLog, 'уже существует объекта с кодом '+parObjCode)
      Exit;
   }

   //--
   var lcRecObj : comp = 0;
   var parObjCRecCode : word = word(getJsonStrValue('ObjectCRecCode',  parJObject))

   if parObjCRecCode = 0
   {
      LogStrToFile( lsImportLog, 'не указан код объекта-родителя  для объекта с кодом '+parObjCode)
      Exit;
   }
   if parObjCRecCode <> parObjCode
   if getFirst JOBJECTS1 where ((  parObjCRecCode == JOBJECTS1.Code )) <> TsOk
   {
      LogStrToFile( lsImportLog, 'не найден объекта-родитель по коду '+parObjCRecCode+' для объекта с кодом '+parObjCode)
      Exit;
   }
   else
      lcRecObj := JOBJECTS1.Nrec;

   //--
   var parObjTableCode : word = word(getJsonStrValue('ObjectTableCode',  parJObject)) ;

   if parObjTableCode = ''
   {
      LogStrToFile( lsImportLog, 'не указан код таблицы для объекта с кодом '+parObjCode)
      Exit;
   }

   if GetFirst X$FILES where (( parObjTableCode == X$FILES.XF$CODE )) <> tsOk
   {
      LogStrToFile( lsImportLog, 'не найдена таблица '+parObjTableCode +' для объекта с кодом '+parObjCode)
      Exit;
   }

   //--
   var parObjectMainKey : string = getJsonStrValue('ObjectMainKey',  parJObject)
   if parObjectMainKey = ''
   {
      LogStrToFile( lsImportLog, 'не указано поле уникального ключа таблицы '+parObjTableCode +' для объекта с кодом '+parObjCRecCode)
      Exit;
   }
   if GetFirst x$Fields where ((  parObjTableCode == x$Fields.xe$FileCode  and parObjectMainKey== x$Fields.XE$NAME )) <> tsOk
   {
      LogStrToFile( lsImportLog, 'не найдено поле уникального ключа '+parObjectMainKey+' таблицы '+parObjTableCode +' для объекта с кодом '+parObjCRecCode)
      Exit;
   }
   //--

     ClearBuffer(#JOBJECTS);
  // set JOBJECTS.Nrec      := 0 ;
     set JOBJECTS.CRec      := lcRecObj ;
     set JOBJECTS.Code      := parObjCode ;
     set JOBJECTS.TableCode := parObjTableCode ;
     set JOBJECTS.MainKey   := parObjectMainKey ;
     set JOBJECTS.NameKey   := getJsonStrValue('ObjectNameKey',  parJObject);
     set JOBJECTS.Name      := getJsonStrValue('ObjectName',     parJObject) ;

    if insert current JOBJECTS = tsOk
    {
       insert MyTableObj set MyTableObj.Nrec := JOBJECTS.nrec
       result := true;

       LogStrToFile( lsImportLog, 'Создан объект с кодом '+parObjCRecCode)

    }
  // NOTES      : LVar    "Примечание объекта"

}
Function  ImportObjectKeys( parJObject : TPtr ) : boolean;
{
   result := false;

   var parFIELDCODE : word = word(getJsonStrValue('FIELDCODE',  parJObject))
   if  parFIELDCODE <> 0
   if  GetFirst x$Fields where ((  JOBJECTS.TableCode == x$Fields.xe$FileCode  and  parFIELDCODE == x$Fields.XE$CODE )) <> tsOk
   {
      LogStrToFile( lsImportLog, 'не найдено поле '+ parFIELDCODE+' таблицы '+JOBJECTS.TableCode +' для объекта с кодом '+JOBJECTS.Code)
      Exit;
   }
   else
   {
      var lbGoodField : boolean= false;

      _try
     {
        if         getJsonStrValue('XENAME',      parJObject)  = x$Fields.XE$NAME
        and  byte( getJsonStrValue('XEDATATYPE',  parJObject)) = x$Fields.XE$DATATYPE
        and  word( getJsonStrValue('XEOFFSET',    parJObject)) = x$Fields.XE$OFFSET
        and  word( getJsonStrValue('XESIZE',      parJObject)) = x$Fields.XE$SIZE
        and  byte( getJsonStrValue('XEPREC',      parJObject)) = x$Fields.XE$PREC
        and  byte( getJsonStrValue('XEDEC',       parJObject)) = x$Fields.XE$DEC
        and  word( getJsonStrValue('XEATTR',      parJObject)) = x$Fields.XE$ATTR
             lbGoodField := true;

     }
     _except   //Стандартные исключения
     else
     {
        LogStrToFile( lsSQLLogFile, 'Ошибка '+ExploreException+' при сравнении структуры поля '+ parFIELDCODE
                                   +' таблицы '+JOBJECTS.TableCode +' для объекта с кодом '+JOBJECTS.Code );
     }
     if not lbGoodField
     {
          LogStrToFile( lsImportLog, 'не совпадает структура поля '+ parFIELDCODE+' таблицы '+JOBJECTS.TableCode +' для объекта с кодом '+JOBJECTS.Code)
          Exit;
     }
   }

   //--
     ClearBuffer(#JObjectsKey)
  // set JObjectsKey.Nrec      := 0
     set JObjectsKey.CRec      := JOBJECTS.Nrec
     set JObjectsKey.TableCode := JOBJECTS.TableCode
     set JObjectsKey.FIELDCODE := parFIELDCODE
     set JObjectsKey.Code      := getJsonStrValue('CODE',  parJObject)
     set JObjectsKey.KeyName   := getJsonStrValue('KeyName',  parJObject)
     set JObjectsKey.KeyType   := getJsonStrValue('KeyType',  parJObject)
     set JObjectsKey.KeyVal    := getJsonStrValue('KeyVal',   parJObject)

    if insert current JObjectsKey = tsOk
        result := true;

}
procedure GetObjectStructIn( parJObject : TPtr; parObjMain : comp );
{

  if parJObject = 0
  {
 //  LogStrToFile( lsImportLog, '   GetObjectIn=000000')
     Exit;
  }

  delete all MyTableObj;

  var ii_1, ii_2 : longint = 0;
  var lnJCount_1, lnJCount_2 : longint;
  var lJsonObjectArray, lJsonObjectArray_1, lJsonObjectArray_2, lJsonObjectArray_3 : TPtr = 0;
  var lnGoodObj : boolean = false;

  lJsonObjectArray := parJObject;

  lnJCount_1 := JCount(lJsonObjectArray);
//LogStrToFile( lsImportLog, 'lnJCount_1='+lnJCount_1)

  for (ii_1 := 0; ii_1 < lnJCount_1; ii_1++)
  {

    lJsonObjectArray_1 := JByIndex(lJsonObjectArray, ii_1);
  //LogStrToFile( lsImportLog, CHR(13)+CHR(13)+'- lJsonObjectArray  объект N ' +ii_1)

    //---- проверка версии и структуры объекта перед импортом
    lnGoodObj := ImportObjectByCode(lJsonObjectArray_1 )

    if NOT lnGoodObj
       break;

    //---- данные внутри объекта // lnJCount_2 строк данных
    lJsonObjectArray_2 := JAByName(lJsonObjectArray_1, 'ObjectKeys');
    lnJCount_2         := JCount(lJsonObjectArray_2);
  //LogStrToFile( lsImportLog, '   в объекте lJsonObjectArray_2 строк lnJCount_2='+lnJCount_2)
    //строки ключей объекта
    for (ii_2 := 0; ii_2 < lnJCount_2; ii_2++)
    {
      //LogStrToFile( lsImportLog, CHR(13)+'--  lJsonObjectArray_2  строка N ' +ii_2)
      //lJsonObjectArray_3 = строка ii_2 объекта lJsonObjectArray_2
        lJsonObjectArray_3 := JByIndex(lJsonObjectArray_2, ii_2);
        lnGoodObj := ImportObjectKeys(lJsonObjectArray_3)
        if NOT lnGoodObj
           break;

    }

    if NOT lnGoodObj
       break;
  }

  if NOT lnGoodObj
  {
     //удалить объекты
     _loop MyTableObj
     if GetFirst JOBJECTS where (( MyTableObj.Nrec == JOBJECTS.Nrec )) = tsOk
     {
        _loop JObjectsKey
          delete current JObjectsKey;

        LogStrToFile( lsImportLog, 'Создан объект с кодом '+JOBJECTS.Code)
        delete current JOBJECTS;
     }
  }

/*
  DestroyJSONObject(lJsonObjectArray);
  DestroyJSONObject(lJsonObjectArray_1);
  DestroyJSONObject(lJsonObjectArray_2);
  DestroyJSONObject(lJsonObjectArray_3);
  DestroyJSONObject(lJsonObjectArray_Data);
  DestroyJSONObject(lJsonObjectArray_ObjIn)
*/
}

//---------
Function GetJsonObjKeysBoby ( parcRec : comp; var parKolVals : longInt ) : TPtr;
{
   var ii         : integer;
   var lnKolVals  : longInt = 0;
   var lcRec      : comp = 0;
   var jsonArr    : TPtr = JACreate;
   var jsonObjArr : TPtr;
   var jsonObjIn, jsonObjVal  : TPtr = 0;

   parKolVals := 0;

   //непосредственно строкитаблицы "JObjectsKey"
   _loop JObjectsKey
   if JObjectsKey.KeyVal <> '[*]'
   {
             jsonObjArr := JCreate;

             JAddString(jsonObjArr, 'Nrec',       JObjectsKey.NRec      );
             JAddString(jsonObjArr, 'CREC',       JObjectsKey.CREC      );
             JAddString(jsonObjArr, 'CODE',       JObjectsKey.CODE      );
             JAddString(jsonObjArr, 'TABLECODE',  JObjectsKey.TABLECODE );
             JAddString(jsonObjArr, 'FIELDCODE',  JObjectsKey.FIELDCODE );
             JAddString(jsonObjArr, 'KeyName',    JObjectsKey.KeyName   );
             JAddString(jsonObjArr, 'KeyType',    JObjectsKey.KeyType   );
             JAddString(jsonObjArr, 'KeyVal',     JObjectsKey.KeyVal    );

        if GetFirst x$Fields_Key = tsOk
        {
             JAddString(jsonObjArr, 'XENAME',     x$Fields_Key.XE$NAME     );
             JAddString(jsonObjArr, 'XEDATATYPE', x$Fields_Key.XE$DATATYPE );
             JAddString(jsonObjArr, 'XEOFFSET',   x$Fields_Key.XE$OFFSET   );
             JAddString(jsonObjArr, 'XESIZE',     x$Fields_Key.XE$SIZE     );
             JAddString(jsonObjArr, 'XEPREC',     x$Fields_Key.XE$PREC     );
             JAddString(jsonObjArr, 'XEDEC',      x$Fields_Key.XE$DEC      );
             JAddString(jsonObjArr, 'XEATTR',     x$Fields_Key.XE$ATTR     );
        }
             //------
             JAAddObject(jsonArr, jsonObjArr);
             parKolVals++;

   }

   result := jsonArr;


}
Function GetJsonObjStructBoby ( parcRec, parObject : comp; var parKolVals : longInt ) : TPtr;
{

   var lnKolVals   : longInt = 0;
   var lcRec       : comp = 0;
   var jsonArrM    : TPtr = JACreate;
   var jsonObjArrM : TPtr = 0;

   parKolVals := 0;

   //по структуре объекта, собранной в GetObjectsTree
   _loop MyTableObj ordered by Index byNpp
   if GetFirst JOBJECTS where (( MyTableObj.Nrec == JOBJECTS.Nrec )) = tsOk
   {
      LogStrToFile(csLogFile, PAD(JOBJECTS.Code,10)+' '+ SubStr(JOBJECTS.name,1, 150) )

         jsonObjArrM := JCreate;
         //заголовок объекта
         JAddString(jsonObjArrM, 'ObjectCode',       JOBJECTS.Code      );
         JAddString(jsonObjArrM, 'ObjectName',       JOBJECTS.Name      );
         JAddString(jsonObjArrM, 'ObjectTableCode',  JOBJECTS.TableCode );
         JAddString(jsonObjArrM, 'ObjectNrec',       JOBJECTS.NRec      );
         JAddString(jsonObjArrM, 'ObjectCRec',       JOBJECTS.CRec      );
         JAddString(jsonObjArrM, 'ObjectNameKey',    JOBJECTS.NameKey   );
         JAddString(jsonObjArrM, 'ObjectMainKey',    JOBJECTS.MainKey   );

         _try  //--- NOTES      : LVar    "Примечание объекта"
         {
            var lsFileMemo : string = 'memo.txt';    DeleteFile(lsFileMemo)
            var lMemo: TPtr = 0;

            if ExportMemoToFile( JOBJECTS.NOTES, 'memo.txt', false)
               lMemo  := HttpConnect_LoadFromFile(fnMemo, lsFileMemo, 0);

            if lMemo <> 0
               JAddLong(jsonObjArrM, 'ObjectNOTES', lMemo);
         }
         _except   //Стандартные исключения
         else
         {
            LogStrToFile( lsSQLLogFile, 'Ошибка '+ExploreException+' экспорта мемо-поля для объекта с кодом '+JOBJECTS.Code );
         }

         //вывод ключей объекта
         JAddObject(jsonObjArrM, 'ObjectKeys',      GetJsonObjKeysBoby( lcRec, lnKolVals ) );
         JAddString(jsonObjArrM, 'ObjectKeysCount', lnKolVals);

         var lcCrec : comp = JOBJECTS.cRec;
         if lcCrec = 0
              JAddString(jsonObjArrM, 'ObjectCRecCode',   JOBJECTS.Code      );
         else
         if GetFirst JOBJECTS where (( lcCrec == JOBJECTS.Nrec )) = tsOk
              JAddString(jsonObjArrM, 'ObjectCRecCode',   JOBJECTS.Code      );

         //--
         JAAddObject(jsonArrM, jsonObjArrM);
         parKolVals++;

   }

   result := jsonArrM;
}
function ExportObjToJsonByTree( parFileName : string; parObject : comp) : string;
{
   fnMemo := HttpConnect_Create('','','');
   fn     := HttpConnect_Create('','','');

   var lnKolVals : longInt;
   var tmpFileJ  : string = 'd:\Obj_'+parFileName+'.json';

   var jsonObj64 : TPtr   = JCreate;

   JAddString(jsonObj64, 'MainObjectName',     parFileName);
   //по корневым объектам
   JAddObject(jsonObj64, 'MainObjectValues',   GetJsonObjStructBoby( 0, parObject, lnKolVals ) );
   JAddString(jsonObj64, 'MainObjectValCount', lnKolVals);

   JToFile(jsonObj64, tmpFileJ, 0, true, true);
   tmpFileJ := ConvertFileANSIUTF8(tmpFileJ);

// Message('tmpFileJ '+tmpFileJ)

   result := tmpFileJ
}

//************************************************************
procedure ImportObjFromJson( parFileName : string = '');
{

  if parFileName = ''
     parFileName := GetFileName('*.json', 'Выберите файл JSON для разбора')

  if parFileName = ''
  or Not ExistFile(parFileName)
     Exit;

  lsImportLog  := parFileName +'_log.txt';     deletefile(lsImportLog);
  lsSQLLogFile := parFileName +'_logSQL.Log';  DeleteFile(lsSQLLogFile)


  fn := HttpConnect_Create('','','');

  var lJsonObjectDocument: TPtr = JFromFile(parFileName, cpUTF8);

//LogStrToFile( lsImportLog, getJsonStrValue('MainObjectName',     lJsonObjectDocument));
//LogStrToFile( lsImportLog, getJsonStrValue('MainObjectValCount', lJsonObjectDocument));

  var lJsonObjectMain : TPtr = JAByName(lJsonObjectDocument, 'MainObjectValues');

  //разбор объектов из файла
  GetObjectStructIn( lJsonObjectMain, 0);

  DestroyJSONObject(lJsonObjectMain);
  DestroyJSONObject(lJsonObjectDocument);


  LogStrToFile(lsImportLog, '==== загрузка завершена  '+parFileName);
  ProcessText(lsImportLog, vfRunModal +vfNewTitle +vfEscable , 'Результат выполнения импорта')

}
