/** Контур/Модуль:                                                                                  *
* Примечание:                                                                                     *
*                                                                                                 *
* Вид работы  |Номер         |Дата    |Исполнитель              |Проект                           *
* ----------------------------------------------------------------------------------------------- *
* Разработка  |#195          |20/09/17|Кириллов Э.П.            |НПО Энергомаш                    *
\*************************************************************************************************/

// объявление стандартной реализации
#include GP_Protector.vih

//------------------------------------------------------------------------------
#doc
  Стандартная реализация интерфейса установки/снятия режима "только чтение" в  заданном контейнере [субконтейнере].
  </brief>
  Защищаются колонки табличного редактора, поля ввода в анкетной форме, чекбоксы и радиокнопки, мемо-поля и поля с
  выпадающим списком. При необходимости связать объект только с главным окном  интерфейса, в качестве имени субконтейнера
  в функцию LinkTo[Ex] передаётся строка "MainWindow" (в любом регистре).
#end
//------------------------------------------------------------------------------
Interface GP_Protector;
  type
#ifdef ATL51
    TStatusCtx = longint;
#else
    TStatusCtx = integer;
#end

  create view
    var
      // хэндл контейнера, контролами которого управляет Протектор
      ProtectedContainer: longint;
      // статус-контекст для режима "только чтение"
      FProtectedStatusCtx: TStatusCtx;
      // признак автоматической установки палитры управляемых окон, соответствующей текущему режиму
      FAutoPalette: boolean;
  ;

  var sLastError:string;

  // все не защищенные от редактирования контролы
  var NonProtectedControls: array[1] of longint;
  // контролы с pickbutton
  var PickableControls: array[1] of longint;
  // контролы с CalendarButton
  var DatedControls: array[1] of longint;
  // контролы с calcbutton
  var CalcableControls: array[1] of longint;
  // контролы со spinbutton
  var SpinnableControls: array[1] of longint;
  // контролы с выпадающим списком
  var ListControls: array[1] of longint;

  // все редактируемые контролы (кроме мемо-полей)
  var EditControls: array[1] of longint;
  // оригинальные статус-строки контролов
  var StatusCtxs: array[1] of TStatusCtx;

  // окна (для автоматического изменения палитры)
  var Windows: array[1] of longint;

  // embedded-панели
  var EmbeddedPanels: longint;

//------------------------------------------------------------------------------
  property AutoPalette: boolean absolute FAutoPalette;

  property ProtectedStatusCtx: longint read FProtectedStatusCtx write SetProtectedStatusCtx(Result);
  
//------------------------------------------------------------------------------
  procedure EmptyArrays;
  {
    SetLimit(NonProtectedControls, 0);
    SetLimit(PickableControls, 0);

    SetLimit(DatedControls, 0);

    SetLimit(CalcableControls, 0);
    SetLimit(SpinnableControls, 0);
    SetLimit(ListControls, 0);

    SetLimit(EditControls, 0);
    SetLimit(StatusCtxs, 0);

    SetLimit(Windows, 0);
  }

//------------------------------------------------------------------------------
  procedure ProcessControls(ContainerId: longint; ProcessChildWindows: boolean);
  {
    var SubContainerList: longint;

    // несортированный маркер для развертки дерева контейнеров
    SubContainerList := InitMarker('', sizeof(longint), if(ProcessChildWindows, 1, 40), 50, false);

    // вершина дерева
    InsertMarker(SubContainerList, ContainerId);

    while GetMarkerCount(SubContainerList) > 0 {
      var CurrentContainer: longint;
      var ObjFullName: string;
      var ObjSelf: longint;
      var ObjContainer: longint;
      var ObjType: longint;

      var I: integer;
      var ObjList: array [1] of longint;

      // очередной контейнер
      GetMarker(SubContainerList, 0, CurrentContainer);
      AtDeleteMarker(SubContainerList, 0);

      if (cfsGetObjInfo(CurrentContainer, ObjFullName, ObjSelf, ObjContainer, ObjType) = cfOk)
      and (ObjType = cfcInterfaceWindow)
        Windows[Count(Windows) + 1] := CurrentContainer;

      SetLimit(ObjList, 0);

      // загрузить список объектов, вставленных в данный контейнер
      if cfsEnumObjects(CurrentContainer, ObjList, ProcessChildWindows) <> cfOk
        continue;

      var Skipped: boolean;
      Skipped:=False;

      for(I := 1; I <= Count(ObjList); Inc(I)) {
        // пропустить недоступные объекты

        if cfsGetProp(ObjList[I], cfpSkip, Skipped) = 0
          if Skipped
            continue;

        if cfsGetObjInfo(ObjList[I], ObjFullName, ObjSelf, ObjContainer, ObjType) <> cfOk
          continue;

        // при необходимости пропустить обработку дочерних окон
        if (ObjType = cfcInterfaceWindow) and not ProcessChildWindows
          continue;

        case ObjType of
          cfcEmbeddedPanel: {
            if EmbeddedPanels <> 0
              // поиск встроенного интерфейса выполняется позже
              InsertMarker(EmbeddedPanels, ObjSelf);
          }

          cfcFieldLine,
          cfcColumn,
          cfcRadioButton,
          cfcCheckBox,
          cfcTreeColumn,
          cfcPanelInputLine,
          cfcPanelRadioButton,
          cfcPanelCheckBox: {
            var BooleanValue: boolean;

            cfsGetProp(ObjList[I], cfpProtect, BooleanValue);
            if not BooleanValue
              // все не защищенные от редактирования контролы
              NonProtectedControls[Count(NonProtectedControls) + 1] := ObjList[I];

            // все контролы с CalendarButton
            cfsGetProp(ObjList[I], cfpCalendarButton, BooleanValue);
            if BooleanValue
              DatedControls[Count(DatedControls) + 1] := ObjList[I];

            cfsGetProp(ObjList[I], cfpPickButton, BooleanValue);
            if BooleanValue
              // все контролы с pickbutton
              PickableControls[Count(PickableControls) + 1] := ObjList[I];
            else
            {
              cfsGetProp(ObjList[I], cfpCalcButton, BooleanValue);
              if BooleanValue
                // все контролы с calcbutton
                CalcableControls[Count(CalcableControls) + 1] := ObjList[I];
              else
              {
                cfsGetProp(ObjList[I], cfpSpinButton, BooleanValue);
                if BooleanValue
                  // все контролы со spinbutton
                  SpinnableControls[Count(SpinnableControls) + 1] := ObjList[I];
              }
            }

            // имеет смысл только для полей с выпадающим списком
            var EnumList: array[1] of string;

            SetLimit(EnumList, 0);
            cfsGetPropArray(ObjList[I], cfpStrings, EnumList);
            if Count(EnumList) > 0
              ListControls[Count(ListControls) + 1] := ObjList[I];

            // оригинальная статус-строка
            var StatusCtx: TStatusCtx;

            cfsGetProp(ObjList[I], cfpStatusCtx, StatusCtx);
            EditControls[Count(EditControls) + 1] := ObjList[I];
            StatusCtxs[Count(StatusCtxs) + 1] := StatusCtx;
          }

          cfcMemoViewer: {
            var BooleanValue: boolean;

            cfsGetProp(ObjList[I], cfpProtect, BooleanValue);
            if not BooleanValue
              // все не защищенные от редактирования контролы
              NonProtectedControls[Count(NonProtectedControls) + 1] := ObjList[I];
          }
        else {
          // возможно, текущий объект сам является субконтейнером
          if SubContainerList <> 0
            InsertMarker(SubContainerList, ObjList[I]);
        }
        end;
      }

      SetLimit(ObjList, 0);
    }
    DoneMarker(SubContainerList, '');
  }

//------------------------------------------------------------------------------
  type
    TInterfaceWindowRec = record
      Id: longint;
      Container: longint;
    end;

//------------------------------------------------------------------------------
//                                                реализации методов IProtector2
//------------------------------------------------------------------------------
  procedure IGP_Protector2.LinkToExt(ContainerId: longint; SubContainerStr: string; ProcessEmbedded: boolean);
  
  {
    ProtectedContainer := ContainerID;
    EmptyArrays;

    if ProtectedContainer = 0
    exit;
    sLastError:='';
    
    var ObjFullName     : string ; ObjFullName     :='';
    var ObjSelf         : longint; ObjSelf         :=0 ;
    var ObjContainer    : longint; ObjContainer    :=0 ;
    var ObjContainerName: string ; ObjContainerName:='';
    var ObjType         : longint; ObjType         :=0 ;
    var Res             : integer; Res             :=0 ;
    EmbeddedPanels := InitMarker('', sizeof(longint), 10, 10);

    Res := cfsSetCurrentContainer(ProtectedContainer);

    if Res <> 0 {
      Message('Текущий контейнер не установлен (' + string(Res) + ')    ', Error + OkButton);
      exit;
    }

    SubContainerStr := Upcase(Trim(SubContainerStr));

    if SubContainerStr = 'MAINWINDOW' {
      ProcessControls(ProtectedContainer, false);
    }
    else {
      if SubContainerStr <> '' {
        var ww_str:string;ww_str:='';
        cfsGetProp(ProtectedContainer,'Name',ww_str);
        //U_STUDENT::RPD_30005&5 
        if pos('::'+SubContainerStr+'&',ww_str)>0
        { SubContainerStr:=SubContainerStr+substr(ww_str,pos('&',ww_str),10);
        }
        Res := cfsGetObjInfo(SubContainerStr, ObjFullName, ObjSelf, ObjContainerName, ObjType);
        if Res <> 0 
        {
#IFDEF _SPB_
          // вообще здесь нужно попробовать повыкусывать - вдруг это второй экземпляр.
          sLastError:=''
          cfsGetProp(ProtectedContainer,'Name',sLastError)
          sLastError:=sLastError+' Связывание с субконтейнером ' + ObjContainerName + '\' + SubContainerStr + ' не выполнено '+    '(' + string(Res) + ')' ;
          timelog(sLastError);
          ProcessControls(ProtectedContainer, true);
          
#ELSe        
          Message('Связывание с субконтейнером ' + ObjContainerName + '\' + SubContainerStr + ' не выполнено '+    '(' + string(Res) + ')', Error + OkButton);
          exit;
#ENDIF          
        }
        else
        {  ProcessControls(ObjSelf, false);
        }
      }
      else
        ProcessControls(ProtectedContainer, true);
    }

    // выгрузить контролы встроенных интерфейсов
    if ProcessEmbedded and (GetMarkerCount(EmbeddedPanels) > 0) {

      var TopObjList: array[1] of longint;
      var ObjList: array[1] of longint;

      SetLimit(TopObjList, 0);

      // объекты верхнего уровня, у которых не задан контейнер
      if (cfsEnumObjects(longint(0), TopObjList, false) = cfOk)
      and (Count(TopObjList) > 0) {

        var InterfaceWindowList: array[1] of TInterfaceWindowRec;
        var TopIndex: integer;

        SetLimit(InterfaceWindowList, 0);

        for (TopIndex := 1; TopIndex <= Count(TopObjList); TopIndex++) {

          if TopObjList[TopIndex] = ContainerId
          continue;

          // текущий контейнер (embedded-панель, если окно встроено)
          var ObjVipContainer: longint; ObjVipContainer:=0;

          // отбросить всё, кроме окон, имеющих ненулевой vip-контейнер
          if (cfsGetObjInfoEx(TopObjList[TopIndex], ObjFullName, ObjSelf, ObjVipContainer, ObjType) <> cfOk)
          or (ObjType <> cfcInterfaceWindow)
          or (ObjVipContainer = 0)
          continue;

          InterfaceWindowList[Count(InterfaceWindowList) + 1].Id := ObjSelf;
          InterfaceWindowList[Count(InterfaceWindowList)].Container := ObjVipContainer;

          SetLimit(ObjList, 0);

          // дочерние окна интерфейсов тоже можно встраивать на панели
          if (cfsEnumObjects(TopObjList[TopIndex], ObjList, false) = cfOk)
          and (Count(ObjList) > 0) {

            var I: integer;

            for (I := 1; I <= Count(ObjList); I++) {
              if (cfsGetObjInfoEx(ObjList[I], ObjFullName, ObjSelf, ObjVipContainer, ObjType) = cfOk)
              and (ObjType = cfcInterfaceWindow) {
                InterfaceWindowList[Count(InterfaceWindowList) + 1].Id := ObjSelf;
                InterfaceWindowList[Count(InterfaceWindowList)].Container := ObjVipContainer;
              }
            }

            SetLimit(ObjList, 0);
          }
        }

        if Count(InterfaceWindowList) > 0 {
          // до тех пор, пока во время обработки контролов будут обнаруживаться embedded-панели
          while GetMarkerCount(EmbeddedPanels) > 0 do {

            var I: integer;

            // выделить окна, связанные с обнаруженными embedded-панелями
            for (I := 1; I <= Count(InterfaceWindowList); I++) {
              if FoundMarker(EmbeddedPanels, InterfaceWindowList[I].Container)
              ObjList[Count(ObjList) + 1] := InterfaceWindowList[I].Id;
            }

            ClearMarker(EmbeddedPanels);

            for (I := 1; I <= Count(ObjList); I++)
            // выгрузить контролы только данного встроенного окна
            ProcessControls(ObjList[I], false);

            SetLimit(ObjList, 0);
          }
        }

        SetLimit(InterfaceWindowList, 0);
        SetLimit(TopObjList, 0);
      }
    }

    DoneMarker(EmbeddedPanels, '');
  }

//------------------------------------------------------------------------------
//                                                 реализации методов IProtector
//------------------------------------------------------------------------------
  procedure IGP_Protector.LinkTo(ContainerId: longint; SubContainerStr: string);
  {
    LinkToExt(ContainerId, SubContainerStr, false);
  }

//------------------------------------------------------------------------------
  procedure IGP_Protector.SetProtectedStatusCtx(Value: longint);
  {
    FProtectedStatusCtx := Value;
  }

//------------------------------------------------------------------------------
  procedure IGP_Protector.SetProtected(Value: boolean);
  {
    var I: integer;

    if cfsSetCurrentContainer(ProtectedContainer) <> 0
      exit;

    if Value
    {
      // контролы с pickbutton
      for (I := 1; I <= Count(PickableControls); Inc(I))
        cfsSetProp(PickableControls[I], cfpPickButton, false);

      // контролы с CalendarButton
      for (I := 1; I <= Count(DatedControls); Inc(I))
        cfsSetProp(DatedControls[I], cfpCalendarButton, false);

      // контролы с calcbutton
      for (I := 1; I <= Count(CalcableControls); Inc(I))
        cfsSetProp(CalcableControls[I], cfpCalcButton, false);

      // контролы со spinbutton
      for (I := 1; I <= Count(SpinnableControls); Inc(I))
        cfsSetProp(SpinnableControls[I], cfpSpinButton, false);

      // все не защищенные от редактирования контролы
      for (I := 1; I <= Count(NonProtectedControls); Inc(I))
        cfsSetProp(NonProtectedControls[I], cfpProtect, true);

      // контролы с выпадающим списком
      for (I := 1; I <= Count(ListControls); Inc(I))
        cfsSetProp(ListControls[I], cfpHistoryID, false);

      // все редактируемые контролы (кроме мемо-полей)
      for (I := 1; I <= Count(EditControls); Inc(I))
        cfsSetProp(EditControls[I], cfpStatusCtx, FProtectedStatusCtx);

      if FAutoPalette
        for (I := 1; I <= Count(Windows); I++)
          cfsSetProp(Windows[I], cfpPalette, integer(wpCyanWindow));
    }
    else
    {
      // все не защищенные от редактирования контролы
      for (I := 1; I <= Count(NonProtectedControls); Inc(I))
        cfsSetProp(NonProtectedControls[I], cfpProtect, false);

      // все редактируемые контролы (кроме мемо-полей)
      for (I := 1; I <= Count(EditControls); Inc(I))
        cfsSetProp(EditControls[I], cfpStatusCtx, StatusCtxs[I]);

      // контролы с pickbutton
      for (I := 1; I <= Count(PickableControls); Inc(I))
        cfsSetProp(PickableControls[I], cfpPickButton, true);

      // контролы с calcbutton
      for (I := 1; I <= Count(CalcableControls); Inc(I))
        cfsSetProp(CalcableControls[I], cfpCalcButton, true);

      // контролы со spinbutton
      for (I := 1; I <= Count(SpinnableControls); Inc(I))
        cfsSetProp(SpinnableControls[I], cfpSpinButton, true);

      // контролы с CalendarButton
      for (I := 1; I <= Count(DatedControls); Inc(I))
        cfsSetProp(DatedControls[I], cfpCalendarButton, true);

      // контролы с выпадающим списком
      for (I := 1; I <= Count(ListControls); Inc(I))
        cfsSetProp(ListControls[I], cfpHistoryID, true);

/*      // все не защищенные от редактирования контролы
      for (I := 1; I <= Count(NonProtectedControls); Inc(I))
        cfsSetProp(NonProtectedControls[I], cfpProtect, false);
*/
      // контролы с выпадающим списком
      //for (I := 1; I <= Count(ListControls); Inc(I))
      //  cfsSetProp(ListControls[I], cfpSkip, false);

/*      // все редактируемые контролы (кроме мемо-полей)
      for (I := 1; I <= Count(EditControls); Inc(I))
        cfsSetProp(EditControls[I], cfpStatusCtx, StatusCtxs[I]);
*/
      if FAutoPalette
        for (I := 1; I <= Count(Windows); I++)
          cfsSetProp(Windows[I], cfpPalette, integer(wpBlueWindow));
    }
  }

//------------------------------------------------------------------------------
  handleevent
    cmOnVipLoad:
    {
      EmptyArrays;
      FProtectedStatusCtx := sci1Esc;
    }
  end;
end.
